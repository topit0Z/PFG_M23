#!/bin/bash
#
#	DTE-Admin-functions
#	Pedro Requena <pf.requena@alumnos.upm.es>
#
# En este fichero se encuentran todas las funciones de las que hacen uso
# los scripts que componen el DTE-Admin


### Funciones auxiliares para el manejo de los diálogos whiptail ###

function _contraseña()
{
	local respuesta=""
	
	respuesta=$(whiptail --title "$TITULO" \
                     --passwordbox "Introduzca la contraseña:" 7 70 \
                     3>&1 1>&2 2>&3)
	echo $respuesta
}

function _confirmacion()
{

	whiptail --title "$TITULO" \
	--yesno "$1" 10 78
}

function _info()
{

	local TERM=ansi #Debemos cambiar temporalmente el tipo de Terminal debido a un bug de whiptail infobox con xterm
	
	txt="$1"
	
	whiptail --title "$TITULO" \
	--infobox "$txt" 10 70
}

function _leer_fichero()
{

	local subtitulo="$1"
	local fichero="$2"

	whiptail --title "$TITULO - $subtitulo" \
	--textbox "$fichero" 7 70 \
	-scrolltext
}

function _mensaje()
{

	local msg="$1"
	
	whiptail --title "$TITULO" \
	--msgbox "$msg" \
	10 70
}

function _formulario()
{

	local pregunta="$1"
	local default="$2"

	local respuesta=$(whiptail --title "$TITULO" \
                     --inputbox "$pregunta" 10 70 "$default" \
                     3>&1 1>&2 2>&3)
                     
        echo $respuesta
}

##########

### Funciones generales ###


function make_backups()
{

	cp -f /etc/default/grub /etc/default/grub.dte_bak
	cp -f /etc/network/interfaces /etc/network/interfaces.dte_bak
	cp -f /etc/sysctl.conf /etc/sysctl.conf.dte_bak
	
return 0
}

function _restore_network()
{

	mv /etc/network/interfaces.dte_bak /etc/network/interfaces
	systemctl restart networking
	
	mv /etc/sysctl.conf.dte_bak /etc/sysctl.conf
		
return 0
}

function _restore_grub()
{
	mv /etc/default/grub.dte_bak /etc/default/grub
	grub-mkconfig -o /boot/grub/grub.cfg

return 0
}

function restore_backups()
{

	_restore_network
	_restore_grub

return 0
}

function instalar_m23()
{

	# Si no existe la clave del repositorio APT de M23, la añadimos
	(apt-key list 2> /dev/null | grep -q "Hauke Goos-Habermann") || (wget -T1 -t1 -q http://m23.sourceforge.net/m23-Sign-Key.asc -O - | apt-key add -)
	
	# Si no existe el repositorio de M23 en los sources de APT, lo añadimos
	[ -f /etc/apt/sources.list.d/m23.list ] || echo 'deb http://m23inst.goos-habermann.de ./' > /etc/apt/sources.list.d/m23.list
	
	#Actualizamos la base de datos de APT
	apt update
	
	#export DEBIAN_FRONTEND=noninteractive
	
	#Instalamos M23 y sus dependencias
	apt install -y m23
	
	#export DEBIAN_FRONTEND=""
	
	_mensaje "La instalación de m23 ha finalizado."
	
	#¿Donde metemos el dpkg-reconfigure?

return 0
}

# Escanea la red de área local en busca de clientes 
# que trate de realizar un arranque PXE
# y almacena sus direcciones MAC en el fichero $result_file
function escanear_MAC()
{

	if [[ $(ip link show eth0 &> /dev/null) ]]; then

		local tmp_file=/tmp/macs_tmp.txt
		
		local result_file=/tmp/macs.txt
		
		local result_file=$(_formulario "Indique el fichero dónde guardar los resultados:" "$HOME/mac.list" ) #Acabar esta mierda
		
		[ -f "$result_file" ] && rm -f $result_file #Borramos el fichero de resultados para no duplicar direcciones MAC
		
		(tcpdump -i eth0 -qtel broadcast and port bootpc >$tmp_file 2>/dev/null)& #Analizamos el tráfico de red en busca de arranques PXE
		_mensaje "Escaneando direcciones MAC...\nPulse aceptar para terminar."
		sudo killall tcpdump
		(perl -ane 'print "\U$F[0]\n"' $tmp_file|sort|uniq) > $result_file
		sed -i '/^$/d' "$result_file"
		rm -f "$tmp_file"
		
		if [ -s "$result_file" ]; then
	      		# The file is not-empty.
			_leer_fichero "Direcciones MAC encontradas:" $result_file
			_mensaje "Las direcciones MAC se han guardado en $result_file"
		else
			# The file is empty.
			_mensaje "No se han encontrado clientes."
		fi
	else
		_mensaje "¡Error! Debe configurar las interfaces de red antes de escanear direcciones MAC."
		return 1
	fi

return 0
}


function get_nombrado_interfaces()
{

	local if_type=""

	cat /etc/default/grub | grep "net.ifnames=0 biosdevname=0" > /dev/null && if_type="Clásico (ethX)" || if_type="Normal (enpXsY, enoX, ...)"
	
	[ "$1" = "show" ] && _mensaje "El nombrado actual de las interfaces de red es:\n$if_type"
	
	echo $if_type

return 0
}

get_static_red()
{	
	
	IPADDR=$(ifconfig eth0 | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p')
	NETMASK=$(ifconfig eth0 | sed -rn '2s/ .*:(.*)$/\1/p')
}

set_dhcp_red()
{

    echo ""  >> "$INTERFACES_FILE"
    echo "allow-hotplug eth1" >> "$INTERFACES_FILE"
    echo "iface eth1 inet dhcp" >> "$INTERFACES_FILE"
    
return 0
}


set_static_red()
{ 

    # set_static_red IP SUBNET GATEWAY
    echo "auto lo" > "$INTERFACES_FILE"
    echo "iface lo inet loopback" >> "$INTERFACES_FILE"
    echo ""  >> "$INTERFACES_FILE"
    echo "auto eth0" >> "$INTERFACES_FILE"
    echo "iface eth0 inet static" >> "$INTERFACES_FILE"
    echo "  address $1" >> "$INTERFACES_FILE"
    echo "  netmask $2" >> "$INTERFACES_FILE"
    #--> En nuestra arquitectura el Gateway es asignado por DHCP en la interfaz eth1, descomentar para cambios de arquitectura de red
    #echo "  gateway $3" >> "$INTERFACES_FILE"
    
    IPADDR=$1
    NETMASK=$2
    #GATEWAY=$3
  
return 0  
}

function configurar_red()
{

	local if_type=$(get_nombrado_interfaces)
	
	
	if [[ $(echo $if_type | grep -q Clásico) || "$1" = "nocheck" ]]; then
		#Estan normales
		_mensaje "Se van a configurar las interfaces de red:\n\neth0 --> con IP fija para conectar con los clientes.\neth1 --> con DHCP para la salida a internet"
		if [[ $(ip link show eth0) || "$1" = "nocheck" ]]; then
		
			local ipaddr=$(_formulario "Indique la dirección IP para eth0:" "10.10.10.10")
			local netmask=$(_formulario "Indique la máscara de Subred:" "255.255.255.0")
			
			#--> En nuestra arquitectura el Gateway es asignado por DHCP en la interfaz eth1, descomentar para cambios de arquitectura de red
			#local gateway=$(_formulario "Indique la dirección de Gateway:" "10.10.10.1") 
			
			set_static_red "$ipaddr" "$netmask"
			_mensaje "La interfaz eth0 ha sido configurada correctamente:\n\nDirección IP --> $ipaddr\nMáscara de Subred --> $netmask"
			
			if [[ $(ip link show eth1) || "$1" = "nocheck" ]]; then
			
				set_dhcp_red
				_mensaje "La interfaz eth1 ha sido configurada correctamente con DHCP."
			
				[ "$1" = "nocheck" ] || { _info "Reiniciando servicio de red...";systemctl restart networking &> /dev/null;ifup eth0 &> /dev/null;ifup eth1 &> /dev/null; }
			
			else
				_mensaje "¡Error! La interfaz eth1 no existe"
				return 1
			fi
		else
			_mensaje "¡Error! La interfaz eth0 no existe"
			return 1
		fi
	else
		_mensaje "¡Error! Debe cambiar el nombrado de interfaces a Clásico para poder configurarlas con el DTE Admin."
		return 1
	fi
	
return 0
}

function set_nombrado_interfaces()
{

	local flag_file=$CONF_DIR/if_conf

	local if_type=$(get_nombrado_interfaces)

	if (_confirmacion "El nombrado actual de las interfaces de red es:\n$if_type\n\n¿Desea cambiarlo?"); then
		_info "Aplicando cambios..."
	    	if [[ $(echo $if_type | grep Normal) ]]; then
			local if_type_final="Clásico (ethX)"	
			sed -ie 's/GRUB_CMDLINE_LINUX="\(.*\)"/GRUB_CMDLINE_LINUX="\1 net.ifnames=0 biosdevname=0"/' /etc/default/grub
			grub-mkconfig -o /boot/grub/grub.cfg &> /dev/null
		else
			local if_type_final="Normal (enpXsY, enoX, ...)"
			
			sed -ie 's/GRUB_CMDLINE_LINUX="\(.*\)"/GRUB_CMDLINE_LINUX=""/' /etc/default/grub
			grub-mkconfig -o /boot/grub/grub.cfg &> /dev/null
		fi
		_mensaje "El nombrado de las interfaces de red se ha cambiado de $if_type a $if_type_final\n\nA continuación se reiniciará el equipo para aplicar los cambios."
		if (_confirmacion "¿Desea configurar la red antes de reniciar?\n De esta forma podrá recuperar su conexión SSH"); then
			configurar_red "nocheck"
		fi
		clear
		reboot&
		exit
	else
		return 1
	fi	
}


#Función obtenida de: https://gist.github.com/tiveone/2506075
function ::netmask2cidr()
{
  case $1 in
      0x*)
      local hex=${1#0x*} quad=
      while [ -n "${hex}" ]; do
        local lastbut2=${hex#??*}
        quad=${quad}${quad:+.}0x${hex%${lastbut2}*}
        hex=${lastbut2}
      done
      set -- ${quad}
      ;;
  esac

  local i= len=
  local IFS=.
  for i in $1; do
    while [ ${i} != "0" ]; do
      len=$((${len} + ${i} % 2))
      i=$((${i} >> 1))
    done
  done

  echo "${len}"
}

function set_ip_forwarding()
{
	get_static_red
	local mask=$(::netmask2cidr "$NETMASK")
	mask=$()
	
	if [[ "IPADDR" != "" && "NETMASK" != "" || "$1" = "nocheck" ]]; then
		if(_confirmacion "Activar el Router virtual permitirá que los clientes accedan a internet a través de esta máquina. ¿Desea continuar?"); then
			
			# Primero, lo activamos a nivel de kernel
			echo 1 > /proc/sys/net/ipv4/ip_forward #Lo activamos
			sed -i '/net.ipv4.ip_forward=1/s/^#//g' /etc/sysctl.conf #Descomentamos la línea para hacerlo persistente
			
			
			#Segundo, configuramos iptables
			iptables -t nat -A POSTROUTING -s "$IPADDR"/"$mask" -o eth1 -j MASQUERADE
			
			#Lo hacemos persistente
			iptables-save > /etc/iptables/rules.v4
			
			touch "$FLAG_CONF_ROUTER_FILE"
			
			_mensaje "El Router Virtual ha sido activado correctamente"
			return 0
		fi	
	else
		_mensaje "¡Error! Debe configurar las interfaces de red para poder activar el Router virtual."
		return 1
	fi
return 0	
}

function unset_ip_forwarding()
{
	if [ -f "$FLAG_CONF_ROUTER_FILE" ]; then
	
		if(_confirmacion "Si desactiva el Router virtual los clientes no podrán accedan a internet a través de esta máquina. ¿Desea continuar?"); then
		
			# Primero, lo desactivamos a nivel de kernel
			echo 0 > /proc/sys/net/ipv4/ip_forward #Lo desactivamos
			sed -i '/net.ipv4.ip_forward=1/s/^/#/g' /etc/sysctl.conf #Comentamos la línea para hacerlo persistente
			
			# Quitamos la regla de iptables
			echo "" > /etc/iptables/rules.v4
			rm -f "$FLAG_CONF_ROUTER_FILE"
			return 0
		fi
	else
		_mensaje "¡Error! El Router virtual no está activado."
		return 1
	fi
return 0	
}

function enviar_fichero()
{
	local file=""
	local host=""
	local user=""
	local pass=""
	local dest_dir=""
	
	file=$(_formulario "Indique el fichero que desea enviar:" "$HOME/mac.list")
	host=$(_formulario "Indique el nombre/dirección del equipo destino:" "10.10.10.2")
	user=$(_formulario "Indique el nombre del usuario destino:" "root")
	pass=$(_contraseña)
	dest=$(_formulario "Indique el directorio de destino:" "/tmp/")
		
	_info "Enviando fichero..."
	
	sshpass -p "$pass" scp "$file" "$user"@"$host":"$dest_dir"
	
	[ $? -eq 0 ] && { _mensaje "Fichero $file enviado con éxito a $host!";return 0; } || { _mensaje "Error al enviar fichero"; return 1; }
	
}
